<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mikhail Gulin — Artworks for Sale</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --text: #1f1f1f;
            --muted: #545454;
            --bg: #f6f7fb;
            --card: #ffffff;
            --accent: #e53935;
        }
        * { box-sizing: border-box; }
        body {
            margin: 0;
            font-family: 'Poppins', sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            scroll-behavior: smooth;
            overscroll-behavior-y: contain;
        }
        header {
            text-align: center;
            padding: 18px 16px 8px;
        }
        header h1 {
            margin: 0;
            font-size: 2rem;
        }
        header p {
            margin: 8px 0 0;
            color: var(--muted);
        }
        main {
            max-width: 1180px;
            margin: 0 auto;
            padding: 0 16px 36px;
        }
        .intro {
            background: linear-gradient(145deg, #fff, #f0f3ff);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.05);
            margin-bottom: 18px;
        }
        .intro h2 {
            margin: 0 0 6px;
            font-size: 1.25rem;
        }
        .intro p {
            margin: 0;
            color: var(--muted);
        }
        .gallery {
            display: flex;
            flex-direction: column;
            gap: 24px;
            scroll-snap-type: y proximity;
        }
        .artwork-item {
            background: var(--card);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 8px 20px rgba(0,0,0,0.08);
            transition: transform 0.2s, box-shadow 0.2s;
            scroll-snap-align: start;
            scroll-snap-stop: normal;
        }
        .artwork-item:active {
            transform: scale(0.98);
        }
        .artwork-image-container {
            position: relative;
            width: 100%;
            background: #f0f0f0;
            cursor: pointer;
            touch-action: pan-x pan-y pinch-zoom;
            overflow: hidden;
            padding: 12px;
            box-sizing: border-box;
        }
        .artwork-image-wrapper {
            width: 100%;
            height: 100%;
            border: 3px solid;
            box-sizing: border-box;
            display: block;
        }
        .artwork-image {
            width: 100%;
            height: auto;
            display: block;
            transition: transform 0.3s ease;
            transform-origin: center center;
        }
        .artwork-image.zoomed {
            transform: scale(2);
            cursor: grab;
            transition: none;
        }
        .artwork-image.zoomed:active {
            cursor: grabbing;
        }
        .artwork-image-container.panning {
            cursor: grabbing;
        }
        .artwork-info {
            padding: 18px 20px;
        }
        .artwork-title {
            margin: 0 0 8px;
            font-size: 1.25rem;
            font-weight: 600;
        }
        .artwork-details {
            margin: 0 0 8px;
            color: var(--muted);
            font-size: 0.95rem;
        }
        .artwork-price {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent);
        }
        .zoom-hint {
            position: absolute;
            bottom: 12px;
            right: 12px;
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        .artwork-image-container:hover .zoom-hint {
            opacity: 1;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--muted);
        }
        @media (max-width: 720px) {
            body {
                scroll-padding-top: 12px;
            }
            .gallery {
                scroll-snap-type: y proximity;
            }
            .artwork-item {
                scroll-margin-top: 10px;
            }
        }
        @media (min-width: 640px) {
            .intro { padding: 18px 20px; }
            .gallery {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                gap: 24px;
            }
        }
        @media (min-width: 1024px) {
            .gallery {
                grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Mikhail Gulin</h1>
        <p>Artworks for Sale</p>
    </header>

    <main>
        <section class="intro">
            <h2>Curated selection</h2>
            <p>Mobile-friendly viewing to explore each piece one by one. Tap or scroll through the works; titles and context appear right below every image.</p>
        </section>

        <section class="gallery" id="gallery" aria-label="Artworks gallery">
            <div class="loading">Loading artworks...</div>
        </section>
    </main>
    <script>
        // Load artworks from JSON
        async function loadArtworks() {
            try {
                const response = await fetch('artworks.json');
                const artworks = await response.json();
                displayArtworks(artworks);
            } catch (error) {
                console.error('Error loading artworks:', error);
                document.getElementById('gallery').innerHTML = 
                    '<div class="loading">Error loading artworks. Please refresh the page.</div>';
            }
        }

        function displayArtworks(artworks) {
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';

            artworks.forEach((artwork, index) => {
                const artworkItem = document.createElement('div');
                artworkItem.className = 'artwork-item';
                
                // Determine which image to use based on screen size
                const imageContainer = document.createElement('div');
                imageContainer.className = 'artwork-image-container';
                
                // Apply frame color from JSON
                const frameColor = artwork.frameColor || '#f5f5dc';
                imageContainer.style.backgroundColor = frameColor;
                
                const imageWrapper = document.createElement('div');
                imageWrapper.className = 'artwork-image-wrapper';
                imageWrapper.style.borderColor = frameColor;
                
                const img = document.createElement('img');
                img.className = 'artwork-image';
                img.alt = artwork.title;
                img.loading = 'lazy';
                
                // Use responsive images
                if (window.innerWidth < 640) {
                    img.src = artwork.imageSmall;
                    img.srcset = `${artwork.imageSmall} 1x, ${artwork.imageLarge} 2x`;
                } else if (window.innerWidth < 1024) {
                    img.src = artwork.imageLarge;
                    img.srcset = `${artwork.imageLarge} 1x, ${artwork.image} 2x`;
                } else {
                    img.src = artwork.image;
                }
                
                const zoomHint = document.createElement('div');
                zoomHint.className = 'zoom-hint';
                zoomHint.textContent = 'Tap to zoom • Pinch to zoom';
                
                imageWrapper.appendChild(img);
                imageContainer.appendChild(imageWrapper);
                imageContainer.appendChild(zoomHint);
                
                // Zoom functionality
                let isZoomed = false;
                let touchStartDistance = 0;
                let initialScale = 1;
                let panStartX = 0;
                let panStartY = 0;
                let currentPanX = 0;
                let currentPanY = 0;
                let isPanning = false;
                
                // Click/tap to zoom
                imageContainer.addEventListener('click', (e) => {
                    if ((e.target === img || e.target === imageWrapper) && !isPanning) {
                        isZoomed = !isZoomed;
                        img.classList.toggle('zoomed', isZoomed);
                        if (!isZoomed) {
                            img.style.transform = 'scale(1) translate(0, 0)';
                            currentPanX = 0;
                            currentPanY = 0;
                        } else {
                            img.style.transform = 'scale(2) translate(0, 0)';
                        }
                    }
                });
                
                // Pan when zoomed (mouse)
                let mouseDown = false;
                imageContainer.addEventListener('mousedown', (e) => {
                    if (isZoomed && (e.target === img || e.target === imageWrapper)) {
                        mouseDown = true;
                        isPanning = true;
                        panStartX = e.clientX - currentPanX;
                        panStartY = e.clientY - currentPanY;
                        imageContainer.classList.add('panning');
                    }
                });
                
                imageContainer.addEventListener('mousemove', (e) => {
                    if (mouseDown && isZoomed) {
                        currentPanX = e.clientX - panStartX;
                        currentPanY = e.clientY - panStartY;
                        const scale = 2;
                        const maxPan = 50; // Limit panning
                        currentPanX = Math.max(-maxPan, Math.min(maxPan, currentPanX));
                        currentPanY = Math.max(-maxPan, Math.min(maxPan, currentPanY));
                        img.style.transform = `scale(${scale}) translate(${currentPanX}px, ${currentPanY}px)`;
                    }
                });
                
                imageContainer.addEventListener('mouseup', () => {
                    mouseDown = false;
                    setTimeout(() => { isPanning = false; }, 100);
                    imageContainer.classList.remove('panning');
                });
                
                imageContainer.addEventListener('mouseleave', () => {
                    mouseDown = false;
                    isPanning = false;
                    imageContainer.classList.remove('panning');
                });
                
                // Pan when zoomed (touch)
                let touchPanStartX = 0;
                let touchPanStartY = 0;
                let isTouchPanning = false;
                
                imageContainer.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1 && isZoomed) {
                        const touch = e.touches[0];
                        touchPanStartX = touch.clientX - currentPanX;
                        touchPanStartY = touch.clientY - currentPanY;
                        isPanning = true;
                        isTouchPanning = true;
                    }
                });
                
                imageContainer.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1 && isZoomed && isTouchPanning) {
                        e.preventDefault();
                        const touch = e.touches[0];
                        currentPanX = touch.clientX - touchPanStartX;
                        currentPanY = touch.clientY - touchPanStartY;
                        const match = img.style.transform.match(/scale\(([\d.]+)\)/);
                        const scale = match ? parseFloat(match[1]) : 2;
                        const maxPan = 100;
                        currentPanX = Math.max(-maxPan, Math.min(maxPan, currentPanX));
                        currentPanY = Math.max(-maxPan, Math.min(maxPan, currentPanY));
                        img.style.transform = `scale(${scale}) translate(${currentPanX}px, ${currentPanY}px)`;
                    }
                });
                
                imageContainer.addEventListener('touchend', () => {
                    setTimeout(() => {
                        isPanning = false;
                        isTouchPanning = false;
                    }, 100);
                });
                
                // Pinch to zoom
                imageContainer.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        isPanning = false; // Disable panning during pinch
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        touchStartDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        const match = img.style.transform.match(/scale\(([\d.]+)\)/);
                        initialScale = match ? parseFloat(match[1]) : (isZoomed ? 2 : 1);
                    }
                });
                
                imageContainer.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const currentDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        const scale = Math.max(1, Math.min(3, initialScale * (currentDistance / touchStartDistance)));
                        img.style.transform = `scale(${scale}) translate(${currentPanX}px, ${currentPanY}px)`;
                        isZoomed = scale > 1.5;
                        img.classList.toggle('zoomed', isZoomed);
                    }
                });
                
                imageContainer.addEventListener('touchend', (e) => {
                    if (e.touches.length < 2) {
                        // Pinch ended, snap to nearest zoom level
                        if (img.style.transform) {
                            const match = img.style.transform.match(/scale\(([\d.]+)\)/);
                            if (match) {
                                const scale = parseFloat(match[1]);
                                const finalScale = scale > 1.5 ? 2 : 1;
                                isZoomed = finalScale > 1;
                                img.style.transform = `scale(${finalScale}) translate(${currentPanX}px, ${currentPanY}px)`;
                                img.classList.toggle('zoomed', isZoomed);
                                if (!isZoomed) {
                                    currentPanX = 0;
                                    currentPanY = 0;
                                    img.style.transform = 'scale(1) translate(0, 0)';
                                }
                            }
                        }
                    }
                });
                
                // Swipe to navigate (on mobile, when zoomed out)
                let touchStartX = 0;
                let touchStartY = 0;
                let swipeStartTime = 0;
                let hasSwiped = false;
                
                imageContainer.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1 && !isZoomed && !isTouchPanning) {
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                        swipeStartTime = Date.now();
                        hasSwiped = false;
                    }
                });
                
                imageContainer.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1 && !isZoomed && !hasSwiped && !isTouchPanning) {
                        const touchX = e.touches[0].clientX;
                        const touchY = e.touches[0].clientY;
                        const deltaX = touchX - touchStartX;
                        const deltaY = touchY - touchStartY;
                        
                        // Horizontal swipe detection - only if horizontal movement is significantly more than vertical
                        if (Math.abs(deltaX) > Math.abs(deltaY) * 2 && Math.abs(deltaX) > 80) {
                            hasSwiped = true;
                            e.preventDefault();
                            const targetIndex = deltaX > 0 ? index - 1 : index + 1;
                            if (targetIndex >= 0 && targetIndex < artworks.length) {
                                setTimeout(() => {
                                    const targetElement = gallery.children[targetIndex];
                                    if (targetElement) {
                                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    }
                                }, 0);
                            }
                        }
                    }
                });
                
                const artworkInfo = document.createElement('div');
                artworkInfo.className = 'artwork-info';
                
                const title = document.createElement('h3');
                title.className = 'artwork-title';
                title.textContent = artwork.title;
                
                const details = document.createElement('p');
                details.className = 'artwork-details';
                const detailParts = [];
                if (artwork.dimensions) detailParts.push(artwork.dimensions + ' cm');
                if (artwork.material) detailParts.push(artwork.material);
                if (artwork.year) detailParts.push(artwork.year);
                details.textContent = detailParts.join(' • ') || 'Dimensions available';
                
                const price = document.createElement('p');
                price.className = 'artwork-price';
                price.textContent = `${parseInt(artwork.price).toLocaleString()} EUR`;
                
                artworkInfo.appendChild(title);
                artworkInfo.appendChild(details);
                artworkInfo.appendChild(price);
                
                artworkItem.appendChild(imageContainer);
                artworkItem.appendChild(artworkInfo);
                
                gallery.appendChild(artworkItem);
            });

            setupGentleSnap(gallery);
        }

        // Gentle mobile snapping with eased settling
        function setupGentleSnap(container) {
            if (container.dataset.snapReady === 'true') return;
            container.dataset.snapReady = 'true';

            const isMobile = () => window.matchMedia('(max-width: 720px)').matches;
            let snapTimer = null;
            let touchActive = false;

            const clearSnapTimer = () => {
                if (snapTimer) {
                    clearTimeout(snapTimer);
                    snapTimer = null;
                }
            };

            const scheduleSnap = () => {
                if (!isMobile()) return;
                clearSnapTimer();
                snapTimer = setTimeout(() => {
                    const items = Array.from(container.querySelectorAll('.artwork-item'));
                    if (!items.length) return;

                    const viewportPadding = 12;
                    const nearest = items.reduce((result, item) => {
                        const rect = item.getBoundingClientRect();
                        const distance = Math.abs(rect.top - viewportPadding);
                        if (!result || distance < result.distance) {
                            return { distance, rect };
                        }
                        return result;
                    }, null);

                    if (nearest && nearest.distance > 6) {
                        const snapTarget = window.scrollY + nearest.rect.top - viewportPadding;
                        window.scrollTo({ top: snapTarget, behavior: 'smooth' });
                    }
                }, 140);
            };

            const handleTouchStart = () => {
                touchActive = true;
                clearSnapTimer();
            };

            const handleTouchEnd = () => {
                touchActive = false;
                scheduleSnap();
            };

            window.addEventListener('scroll', () => {
                if (!isMobile() || touchActive) return;
                scheduleSnap();
            }, { passive: true });

            window.addEventListener('touchstart', handleTouchStart, { passive: true });
            window.addEventListener('touchend', handleTouchEnd, { passive: true });
            window.addEventListener('touchcancel', handleTouchEnd, { passive: true });
        }

        // Handle window resize to update image sources
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Reload artworks to update image sources
                loadArtworks();
            }, 250);
        });

        // Load artworks on page load
        loadArtworks();
    </script>
</body>
</html>
