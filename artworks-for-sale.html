<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mikhail Gulin — Artworks for Sale</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --text: #1f1f1f;
            --muted: #545454;
            --bg: #f6f7fb;
            --card: #ffffff;
            --accent: #e53935;
        }
        * { box-sizing: border-box; }
        body {
            margin: 0;
            font-family: 'Poppins', sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            scroll-behavior: smooth;
            overscroll-behavior-y: contain;
        }
        header {
            text-align: center;
            padding: 18px 16px 8px;
        }
        header h1 {
            margin: 0;
            font-size: 2rem;
        }
        header p {
            margin: 8px 0 0;
            color: var(--muted);
        }
        main {
            max-width: 1180px;
            margin: 0 auto;
            padding: 0 16px 36px;
        }
        .intro {
            background: linear-gradient(145deg, #fff, #f0f3ff);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.05);
            margin-bottom: 18px;
        }
        .intro h2 {
            margin: 0 0 6px;
            font-size: 1.25rem;
        }
        .intro p {
            margin: 0;
            color: var(--muted);
        }
        .gallery {
            display: flex;
            flex-direction: column;
            gap: 24px;
            scroll-snap-type: y proximity;
        }
        .snap-container {
            scroll-snap-type: var(--snap-axis, y) proximity;
            scroll-behavior: smooth;
        }
        .snap-item {
            scroll-snap-align: start;
            scroll-snap-stop: always;
        }
        .artwork-item {
            background: var(--card);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 8px 20px rgba(0,0,0,0.08);
            transition: transform 0.2s, box-shadow 0.2s;
            scroll-snap-align: start;
            scroll-snap-stop: always;
        }
        .artwork-item:active {
            transform: scale(0.98);
        }
        .artwork-image-container {
            position: relative;
            width: 100%;
            background: #f0f0f0;
            cursor: pointer;
            touch-action: pan-x pan-y pinch-zoom;
            overflow: hidden;
            padding: 12px;
            box-sizing: border-box;
        }
        .artwork-image-wrapper {
            width: 100%;
            height: 100%;
            border: 3px solid;
            box-sizing: border-box;
            display: block;
        }
        .artwork-image {
            width: 100%;
            height: auto;
            display: block;
            transition: transform 0.3s ease;
            transform-origin: center center;
        }
        .artwork-image.zoomed {
            transform: scale(2);
            cursor: grab;
            transition: none;
        }
        .artwork-image.zoomed:active {
            cursor: grabbing;
        }
        .artwork-image-container.panning {
            cursor: grabbing;
        }
        .artwork-info {
            padding: 18px 20px;
        }
        .artwork-title {
            margin: 0 0 8px;
            font-size: 1.25rem;
            font-weight: 600;
        }
        .artwork-details {
            margin: 0 0 8px;
            color: var(--muted);
            font-size: 0.95rem;
        }
        .artwork-price {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent);
        }
        .zoom-hint {
            position: absolute;
            bottom: 12px;
            right: 12px;
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        .artwork-image-container:hover .zoom-hint {
            opacity: 1;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--muted);
        }
        .snap-notes {
            margin-top: 28px;
            background: var(--card);
            border-radius: 14px;
            box-shadow: 0 10px 24px rgba(0,0,0,0.08);
            padding: 18px 16px;
        }
        .snap-notes pre {
            background: #0f172a;
            color: #e2e8f0;
            padding: 12px;
            border-radius: 10px;
            overflow: auto;
            font-size: 0.85rem;
            line-height: 1.5;
            white-space: pre-wrap;
        }
        .snap-demo {
            margin-top: 32px;
            background: var(--card);
            border-radius: 14px;
            box-shadow: 0 10px 24px rgba(0,0,0,0.08);
            padding: 18px 14px 12px;
        }
        .snap-demo h3 {
            margin: 0 0 12px;
        }
        .snap-demo .demo-track {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding: 6px 4px 12px;
            scroll-padding: 0 18px;
            --snap-axis: x;
            scroll-snap-type: x mandatory;
        }
        .snap-demo .demo-card {
            flex: 0 0 82%;
            max-width: 340px;
            border-radius: 12px;
            background: linear-gradient(135deg, #f7f9ff, #edf1ff);
            padding: 12px;
            border: 1px solid #e5e9ff;
            scroll-snap-align: center;
            scroll-snap-stop: always;
        }
        .snap-demo .demo-card img {
            width: 100%;
            height: auto;
            border-radius: 10px;
            display: block;
        }
        .snap-demo .demo-card p {
            margin: 8px 0 0;
            color: var(--muted);
            font-size: 0.95rem;
        }
        @media (max-width: 720px) {
            body {
                scroll-padding-top: 12px;
            }
            .gallery {
                scroll-snap-type: y mandatory;
            }
            .artwork-item {
                scroll-margin-top: 10px;
            }
        }
        @media (min-width: 640px) {
            .intro { padding: 18px 20px; }
            .gallery {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                gap: 24px;
            }
            .snap-demo .demo-track {
                scroll-snap-type: none;
            }
            .snap-demo .demo-card {
                scroll-snap-align: none;
                scroll-snap-stop: normal;
            }
        }
        @media (min-width: 1024px) {
            .gallery {
                grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Mikhail Gulin</h1>
        <p>Artworks for Sale</p>
    </header>

    <main>
        <section class="intro">
            <h2>Curated selection</h2>
            <p>Mobile-friendly viewing to explore each piece one by one. Tap or scroll through the works; titles and context appear right below every image.</p>
        </section>

        <section class="gallery" id="gallery" aria-label="Artworks gallery">
            <div class="loading">Loading artworks...</div>
        </section>

        <section class="snap-demo" aria-label="Horizontal snap scrolling demo">
            <h3>Snap-scrolling cards (horizontal)</h3>
            <p class="artwork-details">Soft snapping keeps each card centered when you lift your finger.</p>
            <div class="demo-track snap-container" id="snap-demo-track" tabindex="0" aria-label="Snap scrolling cards">
                <div class="demo-card snap-item">
                    <img src="img/a/mobile-small/Unknown_12_100x100_small.jpg" alt="Demo artwork one">
                    <p>Centered snap keeps a single card in view.</p>
                </div>
                <div class="demo-card snap-item">
                    <img src="img/a/mobile-small/Unknown_9_120x100_small.jpg" alt="Demo artwork two">
                    <p>Supports gentle drags and natural inertia.</p>
                </div>
                <div class="demo-card snap-item">
                    <img src="img/a/mobile-small/Future_governor_60x90_small.jpg" alt="Demo artwork three">
                    <p>Horizontal snapping mirrors vertical behaviour.</p>
                </div>
                <div class="demo-card snap-item">
                    <img src="img/a/mobile-small/Unknown_13_120x100_small.jpg" alt="Demo artwork four">
                    <p>Keyboard focus and scroll remain accessible.</p>
                </div>
            </div>
        </section>

        <section class="snap-notes" aria-label="Native snap scrolling references">
            <h3>Native reference implementations</h3>
            <p class="artwork-details">Reuse the same thresholds on iOS/Android to match the web experience.</p>
            <pre aria-label="Swift UIScrollView snapping example">// Swift (UIKit)
class SnapScrollView: UIScrollView, UIScrollViewDelegate {
    var snapSpacing: CGFloat = 12
    var snapAlignment: CGFloat = 0.5 // 0 = top, 0.5 = center
    var snapVelocityThreshold: CGFloat = 0.55

    override init(frame: CGRect) {
        super.init(frame: frame)
        delegate = self
        decelerationRate = .fast
        showsVerticalScrollIndicator = false
    }

    required init?(coder: NSCoder) { fatalError("init(coder:) has not been implemented") }

    func scrollViewWillEndDragging(_ scrollView: UIScrollView,
                                   withVelocity velocity: CGPoint,
                                   targetContentOffset: UnsafeMutablePointer<CGPoint>) {
        let isVertical = contentSize.height > contentSize.width
        let axisVelocity = isVertical ? velocity.y : velocity.x
        if abs(axisVelocity) > snapVelocityThreshold { return }

        let viewport = isVertical ? bounds.height : bounds.width
        var closest: CGFloat = targetContentOffset.pointee.y
        var bestDistance = CGFloat.greatestFiniteMagnitude

        for sub in subviews where sub.frame.intersects(bounds.insetBy(dx: -viewport, dy: -viewport)) {
            let origin = isVertical ? sub.frame.minY : sub.frame.minX
            let size = isVertical ? sub.frame.height : sub.frame.width
            let target = origin - (viewport - size) * snapAlignment
            let distance = abs(target - (isVertical ? contentOffset.y : contentOffset.x))
            if distance < bestDistance {
                bestDistance = distance
                closest = target
            }
        }
        targetContentOffset.pointee = isVertical ? CGPoint(x: 0, y: closest) : CGPoint(x: closest, y: 0)
    }
}</pre>
            <pre aria-label="Android RecyclerView snapping example">// Kotlin (RecyclerView)
class SoftSnapHelper(
    private val snapAlignment: Float = 0f, // 0f = start, 0.5f = center
    private val velocityThreshold: Float = 0.55f
) : PagerSnapHelper() {
    override fun findTargetSnapPosition(layoutManager: RecyclerView.LayoutManager, velocityX: Int, velocityY: Int): Int {
        if (abs(velocityX) > velocityThreshold * 1000 || abs(velocityY) > velocityThreshold * 1000) {
            return RecyclerView.NO_POSITION
        }
        val orientationHelper = if (layoutManager.canScrollVertically())
            OrientationHelper.createVerticalHelper(layoutManager)
        else OrientationHelper.createHorizontalHelper(layoutManager)

        var closestPos = RecyclerView.NO_POSITION
        var closestDistance = Int.MAX_VALUE
        val center = (orientationHelper.startAfterPadding + orientationHelper.totalSpace * snapAlignment).toInt()

        for (i in 0 until layoutManager.childCount) {
            val child = layoutManager.getChildAt(i) ?: continue
            val distance = abs(orientationHelper.getDecoratedStart(child) - center)
            if (distance < closestDistance) {
                closestDistance = distance
                closestPos = layoutManager.getPosition(child)
            }
        }
        return closestPos
    }
}</pre>
        </section>
    </main>
    <script>
        class SnapScroller {
            constructor(container, options = {}) {
                this.container = container;
                this.options = Object.assign({
                    orientation: 'vertical',
                    snapAlignment: 'start',
                    velocityThreshold: 0.45, // px per ms
                    snapEpsilon: 36,
                    stayVelocity: 0.08,
                    idleTimeout: 90,
                    enable: () => true,
                }, options);

                this.axis = this.options.orientation === 'horizontal' ? 'left' : 'top';
                this.snapItems = Array.from(container.querySelectorAll('.snap-item'));
                this.lastPos = this.currentPosition();
                this.lastTime = performance.now();
                this.velocity = 0;
                this.scrollEndTimer = null;
                this.animFrame = null;

                this.onScroll = this.onScroll.bind(this);
                this.onInteractionEnd = this.onInteractionEnd.bind(this);
                this.onResize = this.onResize.bind(this);
                container.addEventListener('scroll', this.onScroll, { passive: true });
                container.addEventListener('touchend', this.onInteractionEnd, { passive: true });
                container.addEventListener('mouseup', this.onInteractionEnd, { passive: true });
                window.addEventListener('resize', this.onResize, { passive: true });
            }

            currentPosition() {
                return this.options.orientation === 'horizontal'
                    ? this.container.scrollLeft
                    : this.container.scrollTop;
            }

            viewportSize() {
                return this.options.orientation === 'horizontal'
                    ? this.container.clientWidth
                    : this.container.clientHeight;
            }

            itemSize(el) {
                return this.options.orientation === 'horizontal' ? el.offsetWidth : el.offsetHeight;
            }

            offsetFromStart(el) {
                const rect = el.getBoundingClientRect();
                const containerRect = this.container.getBoundingClientRect();
                return this.options.orientation === 'horizontal'
                    ? rect.left - containerRect.left
                    : rect.top - containerRect.top;
            }

            onScroll() {
                const now = performance.now();
                const position = this.currentPosition();
                const delta = position - this.lastPos;
                const dt = now - this.lastTime || 1;
                this.velocity = delta / dt;
                this.lastPos = position;
                this.lastTime = now;

                clearTimeout(this.scrollEndTimer);
                this.scrollEndTimer = setTimeout(() => this.handleScrollEnd(false), this.options.idleTimeout);
            }

            onInteractionEnd() {
                this.handleScrollEnd(true);
            }

            onResize() {
                this.snapItems = Array.from(this.container.querySelectorAll('.snap-item'));
            }

            handleScrollEnd(force) {
                if (!this.options.enable()) return;
                const velocityMagnitude = Math.abs(this.velocity);
                if (!force && velocityMagnitude > this.options.velocityThreshold) {
                    return; // let strong flicks finish naturally
                }

                const { target } = this.findNearestSnap();
                if (target === undefined) return;

                const distance = Math.abs(target - this.currentPosition());
                if (distance < this.options.snapEpsilon && velocityMagnitude < this.options.stayVelocity) {
                    return; // respect intentional small stops
                }
                this.animateTo(target);
            }

            findNearestSnap() {
                let nearest = { distance: Number.MAX_VALUE };
                const current = this.currentPosition();
                const viewport = this.viewportSize();

                this.snapItems.forEach((el) => {
                    const offset = this.offsetFromStart(el);
                    const size = this.itemSize(el);
                    let target = current + offset;

                    if (this.options.snapAlignment === 'center') {
                        target = target - (viewport - size) / 2;
                    }

                    const distance = Math.abs(target - current);
                    if (distance < nearest.distance) {
                        nearest = { distance, target, element: el };
                    }
                });

                return nearest;
            }

            animateTo(target) {
                if (!Number.isFinite(target)) return;
                cancelAnimationFrame(this.animFrame);
                const start = this.currentPosition();
                const change = target - start;
                if (Math.abs(change) < 1) return;
                const duration = Math.min(650, Math.max(220, Math.abs(change) * 0.6));
                const startTime = performance.now();

                const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

                const step = () => {
                    const now = performance.now();
                    const progress = Math.min(1, (now - startTime) / duration);
                    const eased = easeOutCubic(progress);
                    const value = start + change * eased;
                    this.container.scrollTo({
                        left: this.options.orientation === 'horizontal' ? value : undefined,
                        top: this.options.orientation === 'vertical' ? value : undefined,
                        behavior: 'auto',
                    });
                    if (progress < 1) {
                        this.animFrame = requestAnimationFrame(step);
                    }
                };

                this.animFrame = requestAnimationFrame(step);
            }

            destroy() {
                cancelAnimationFrame(this.animFrame);
                clearTimeout(this.scrollEndTimer);
                this.container.removeEventListener('scroll', this.onScroll);
                this.container.removeEventListener('touchend', this.onInteractionEnd);
                this.container.removeEventListener('mouseup', this.onInteractionEnd);
                window.removeEventListener('resize', this.onResize);
            }
        }

        // Load artworks from JSON
        async function loadArtworks() {
            try {
                const response = await fetch('artworks.json');
                const artworks = await response.json();
                displayArtworks(artworks);
            } catch (error) {
                console.error('Error loading artworks:', error);
                document.getElementById('gallery').innerHTML = 
                    '<div class="loading">Error loading artworks. Please refresh the page.</div>';
            }
        }

        let gallerySnapper;
        function displayArtworks(artworks) {
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';

            artworks.forEach((artwork, index) => {
                const artworkItem = document.createElement('div');
                artworkItem.className = 'artwork-item snap-item';
                
                // Determine which image to use based on screen size
                const imageContainer = document.createElement('div');
                imageContainer.className = 'artwork-image-container';
                
                // Apply frame color from JSON
                const frameColor = artwork.frameColor || '#f5f5dc';
                imageContainer.style.backgroundColor = frameColor;
                
                const imageWrapper = document.createElement('div');
                imageWrapper.className = 'artwork-image-wrapper';
                imageWrapper.style.borderColor = frameColor;
                
                const img = document.createElement('img');
                img.className = 'artwork-image';
                img.alt = artwork.title;
                img.loading = 'lazy';
                
                // Use responsive images
                if (window.innerWidth < 640) {
                    img.src = artwork.imageSmall;
                    img.srcset = `${artwork.imageSmall} 1x, ${artwork.imageLarge} 2x`;
                } else if (window.innerWidth < 1024) {
                    img.src = artwork.imageLarge;
                    img.srcset = `${artwork.imageLarge} 1x, ${artwork.image} 2x`;
                } else {
                    img.src = artwork.image;
                }
                
                const zoomHint = document.createElement('div');
                zoomHint.className = 'zoom-hint';
                zoomHint.textContent = 'Tap to zoom • Pinch to zoom';
                
                imageWrapper.appendChild(img);
                imageContainer.appendChild(imageWrapper);
                imageContainer.appendChild(zoomHint);
                
                // Zoom functionality
                let isZoomed = false;
                let touchStartDistance = 0;
                let initialScale = 1;
                let panStartX = 0;
                let panStartY = 0;
                let currentPanX = 0;
                let currentPanY = 0;
                let isPanning = false;
                
                // Click/tap to zoom
                imageContainer.addEventListener('click', (e) => {
                    if ((e.target === img || e.target === imageWrapper) && !isPanning) {
                        isZoomed = !isZoomed;
                        img.classList.toggle('zoomed', isZoomed);
                        if (!isZoomed) {
                            img.style.transform = 'scale(1) translate(0, 0)';
                            currentPanX = 0;
                            currentPanY = 0;
                        } else {
                            img.style.transform = 'scale(2) translate(0, 0)';
                        }
                    }
                });
                
                // Pan when zoomed (mouse)
                let mouseDown = false;
                imageContainer.addEventListener('mousedown', (e) => {
                    if (isZoomed && (e.target === img || e.target === imageWrapper)) {
                        mouseDown = true;
                        isPanning = true;
                        panStartX = e.clientX - currentPanX;
                        panStartY = e.clientY - currentPanY;
                        imageContainer.classList.add('panning');
                    }
                });
                
                imageContainer.addEventListener('mousemove', (e) => {
                    if (mouseDown && isZoomed) {
                        currentPanX = e.clientX - panStartX;
                        currentPanY = e.clientY - panStartY;
                        const scale = 2;
                        const maxPan = 50; // Limit panning
                        currentPanX = Math.max(-maxPan, Math.min(maxPan, currentPanX));
                        currentPanY = Math.max(-maxPan, Math.min(maxPan, currentPanY));
                        img.style.transform = `scale(${scale}) translate(${currentPanX}px, ${currentPanY}px)`;
                    }
                });
                
                imageContainer.addEventListener('mouseup', () => {
                    mouseDown = false;
                    setTimeout(() => { isPanning = false; }, 100);
                    imageContainer.classList.remove('panning');
                });
                
                imageContainer.addEventListener('mouseleave', () => {
                    mouseDown = false;
                    isPanning = false;
                    imageContainer.classList.remove('panning');
                });
                
                // Pan when zoomed (touch)
                let touchPanStartX = 0;
                let touchPanStartY = 0;
                let isTouchPanning = false;
                
                imageContainer.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1 && isZoomed) {
                        const touch = e.touches[0];
                        touchPanStartX = touch.clientX - currentPanX;
                        touchPanStartY = touch.clientY - currentPanY;
                        isPanning = true;
                        isTouchPanning = true;
                    }
                });
                
                imageContainer.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1 && isZoomed && isTouchPanning) {
                        e.preventDefault();
                        const touch = e.touches[0];
                        currentPanX = touch.clientX - touchPanStartX;
                        currentPanY = touch.clientY - touchPanStartY;
                        const match = img.style.transform.match(/scale\(([\d.]+)\)/);
                        const scale = match ? parseFloat(match[1]) : 2;
                        const maxPan = 100;
                        currentPanX = Math.max(-maxPan, Math.min(maxPan, currentPanX));
                        currentPanY = Math.max(-maxPan, Math.min(maxPan, currentPanY));
                        img.style.transform = `scale(${scale}) translate(${currentPanX}px, ${currentPanY}px)`;
                    }
                });
                
                imageContainer.addEventListener('touchend', () => {
                    setTimeout(() => {
                        isPanning = false;
                        isTouchPanning = false;
                    }, 100);
                });
                
                // Pinch to zoom
                imageContainer.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        isPanning = false; // Disable panning during pinch
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        touchStartDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        const match = img.style.transform.match(/scale\(([\d.]+)\)/);
                        initialScale = match ? parseFloat(match[1]) : (isZoomed ? 2 : 1);
                    }
                });
                
                imageContainer.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const currentDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        const scale = Math.max(1, Math.min(3, initialScale * (currentDistance / touchStartDistance)));
                        img.style.transform = `scale(${scale}) translate(${currentPanX}px, ${currentPanY}px)`;
                        isZoomed = scale > 1.5;
                        img.classList.toggle('zoomed', isZoomed);
                    }
                });
                
                imageContainer.addEventListener('touchend', (e) => {
                    if (e.touches.length < 2) {
                        // Pinch ended, snap to nearest zoom level
                        if (img.style.transform) {
                            const match = img.style.transform.match(/scale\(([\d.]+)\)/);
                            if (match) {
                                const scale = parseFloat(match[1]);
                                const finalScale = scale > 1.5 ? 2 : 1;
                                isZoomed = finalScale > 1;
                                img.style.transform = `scale(${finalScale}) translate(${currentPanX}px, ${currentPanY}px)`;
                                img.classList.toggle('zoomed', isZoomed);
                                if (!isZoomed) {
                                    currentPanX = 0;
                                    currentPanY = 0;
                                    img.style.transform = 'scale(1) translate(0, 0)';
                                }
                            }
                        }
                    }
                });
                
                // Swipe to navigate (on mobile, when zoomed out)
                let touchStartX = 0;
                let touchStartY = 0;
                let swipeStartTime = 0;
                let hasSwiped = false;
                
                imageContainer.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1 && !isZoomed && !isTouchPanning) {
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                        swipeStartTime = Date.now();
                        hasSwiped = false;
                    }
                });
                
                imageContainer.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1 && !isZoomed && !hasSwiped && !isTouchPanning) {
                        const touchX = e.touches[0].clientX;
                        const touchY = e.touches[0].clientY;
                        const deltaX = touchX - touchStartX;
                        const deltaY = touchY - touchStartY;
                        
                        // Horizontal swipe detection - only if horizontal movement is significantly more than vertical
                        if (Math.abs(deltaX) > Math.abs(deltaY) * 2 && Math.abs(deltaX) > 80) {
                            hasSwiped = true;
                            e.preventDefault();
                            const targetIndex = deltaX > 0 ? index - 1 : index + 1;
                            if (targetIndex >= 0 && targetIndex < artworks.length) {
                                setTimeout(() => {
                                    const targetElement = gallery.children[targetIndex];
                                    if (targetElement) {
                                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    }
                                }, 0);
                            }
                        }
                    }
                });
                
                const artworkInfo = document.createElement('div');
                artworkInfo.className = 'artwork-info';
                
                const title = document.createElement('h3');
                title.className = 'artwork-title';
                title.textContent = artwork.title;
                
                const details = document.createElement('p');
                details.className = 'artwork-details';
                const detailParts = [];
                if (artwork.dimensions) detailParts.push(artwork.dimensions + ' cm');
                if (artwork.material) detailParts.push(artwork.material);
                if (artwork.year) detailParts.push(artwork.year);
                details.textContent = detailParts.join(' • ') || 'Dimensions available';
                
                const price = document.createElement('p');
                price.className = 'artwork-price';
                price.textContent = `${parseInt(artwork.price).toLocaleString()} EUR`;
                
                artworkInfo.appendChild(title);
                artworkInfo.appendChild(details);
                artworkInfo.appendChild(price);
                
                artworkItem.appendChild(imageContainer);
                artworkItem.appendChild(artworkInfo);
                
                gallery.appendChild(artworkItem);
            });

            if (gallerySnapper) {
                gallerySnapper.destroy();
            }
            gallerySnapper = new SnapScroller(gallery, {
                orientation: 'vertical',
                snapAlignment: 'start',
                snapEpsilon: 52,
                velocityThreshold: 0.55,
                stayVelocity: 0.06,
                enable: () => window.matchMedia('(max-width: 720px)').matches,
            });
        }

        // Handle window resize to update image sources
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Reload artworks to update image sources
                loadArtworks();
            }, 250);
        });

        function initDemoSnapper() {
            const demoTrack = document.getElementById('snap-demo-track');
            demoTrack.classList.add('snap-container');
            demoTrack.querySelectorAll('.demo-card').forEach((card) => card.classList.add('snap-item'));
            return new SnapScroller(demoTrack, {
                orientation: 'horizontal',
                snapAlignment: 'center',
                snapEpsilon: 40,
                velocityThreshold: 0.6,
                stayVelocity: 0.08,
                enable: () => window.matchMedia('(max-width: 900px)').matches,
            });
        }

        let demoSnapper;
        // Load artworks on page load
        loadArtworks();
        demoSnapper = initDemoSnapper();
    </script>
</body>
</html>
